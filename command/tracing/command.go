package tracing

import (
	"errors"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"golang.org/x/mod/modfile"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
)

func Run(source string, destination io.Writer, decorName string, packageName string) error {
	fset := token.NewFileSet()
	interfaceNode, err := parser.ParseFile(fset, source, nil, parser.ParseComments)
	if err != nil {
		return err
	}

	if packageName == "" {
		packageName = interfaceNode.Name.Name
	}

	decorNode := &ast.File{
		Name:  ast.NewIdent(packageName),
		Decls: make([]ast.Decl, 0),
	}

	importDecl := &ast.GenDecl{
		Tok:   token.IMPORT,
		Specs: make([]ast.Spec, 0),
	}

	for _, f := range interfaceNode.Decls {
		genD, ok := f.(*ast.GenDecl)
		if !ok {
			fmt.Printf("SKIP %T is not *ast.GenDecl\n", f)
			continue
		}

		for _, spec := range genD.Specs {
			currImport, ok := spec.(*ast.ImportSpec)
			if ok {
				importDecl.Specs = append(importDecl.Specs, currImport)
				continue
			}
		}
	}

	importDecl.Specs = append(
		importDecl.Specs,
		&ast.ImportSpec{
			Path: stringLit("go.opentelemetry.io/otel"),
		},
		&ast.ImportSpec{
			Path: stringLit("go.opentelemetry.io/otel/codes"),
		},
	)

	decorNode.Decls = append(decorNode.Decls, importDecl)

	for _, f := range interfaceNode.Decls {
		genD, ok := f.(*ast.GenDecl)
		if !ok {
			fmt.Printf("SKIP %T is not *ast.GenDecl\n", f)
			continue
		}

		for _, spec := range genD.Specs {
			currType, ok := spec.(*ast.TypeSpec)
			if !ok {
				fmt.Printf("SKIP %T is not ast.TypeSpec\n", spec)
				continue
			}

			currInterface, ok := currType.Type.(*ast.InterfaceType)
			if !ok {
				fmt.Printf("SKIP %T is not ast.InterfaceType\n", currInterface)
				continue
			}

			var interfaceName ast.Expr
			if packageName != interfaceNode.Name.Name {
				interfaceName = &ast.SelectorExpr{
					X:   interfaceNode.Name,
					Sel: ast.NewIdent(currType.Name.Name),
				}
				importDecl.Specs = append(
					importDecl.Specs,
					&ast.ImportSpec{
						Name: interfaceNode.Name,
						Path: stringLit(outputPackagePath(source)),
					},
				)
			} else {
				interfaceName = ast.NewIdent(currType.Name.Name)
			}

			structFields := &ast.FieldList{
				List: []*ast.Field{
					{
						Names: []*ast.Ident{{Name: "origin"}},
						Type:  parameterizedType(interfaceName, currType),
					},
					{
						Names: []*ast.Ident{{Name: "tracerName"}},
						Type:  ast.NewIdent("string"),
					},
				},
			}

			decorNode.Decls = append(
				decorNode.Decls,

				// type definition
				&ast.GenDecl{
					Tok: token.TYPE,
					Specs: []ast.Spec{
						&ast.TypeSpec{
							Name:       ast.NewIdent(decorName),
							TypeParams: currType.TypeParams,
							Type: &ast.StructType{
								Fields: structFields,
							},
						},
					},
				},

				// type constructor
				&ast.FuncDecl{
					Name: ast.NewIdent(fmt.Sprintf("New%s", decorName)),
					Type: &ast.FuncType{
						Params: structFields,
						Results: &ast.FieldList{
							List: []*ast.Field{
								{
									Type: &ast.StarExpr{
										X: ast.NewIdent(decorName),
									},
								},
							},
						},
					},
					Body: &ast.BlockStmt{
						List: []ast.Stmt{
							&ast.ReturnStmt{
								Results: []ast.Expr{
									&ast.UnaryExpr{
										Op: token.AND,
										X: &ast.CompositeLit{
											Type: ast.NewIdent(decorName),
											Elts: []ast.Expr{
												&ast.KeyValueExpr{
													Key:   ast.NewIdent("origin"),
													Value: ast.NewIdent("origin"),
												},
												&ast.KeyValueExpr{
													Key:   ast.NewIdent("tracerName"),
													Value: ast.NewIdent("tracerName"),
												},
											},
										},
									},
								},
							},
						},
					},
				},
			)

			if currInterface.Methods != nil {
				for _, method := range currInterface.Methods.List {

					ast.Inspect(method, func(node ast.Node) bool {
						ftype, ok := method.Type.(*ast.FuncType)
						if !ok {
							return false
						}

						if ftype.Params != nil {
							for fIdx, field := range ftype.Params.List {
								if len(field.Names) == 0 {
									if isContext(field.Type) {
										field.Names = []*ast.Ident{ast.NewIdent("ctx")}
									} else {
										field.Names = []*ast.Ident{ast.NewIdent(fmt.Sprintf("var%d", fIdx))}
									}
								}
							}
						}

						return false
					})

					decorNode.Decls = append(
						decorNode.Decls,
						&ast.FuncDecl{
							Doc: nil,
							Recv: &ast.FieldList{ // receiver (e.g. `(d *Decor[A, B])`)
								List: []*ast.Field{
									{
										Names: []*ast.Ident{{Name: "d"}},
										Type: &ast.StarExpr{
											X: parameterizedType(ast.NewIdent(decorName), currType),
										},
									},
								},
							},
							Name: method.Names[0],
							Type: method.Type.(*ast.FuncType),
							Body: funcBodyWithTracing(method),
						},
					)
				}
			}
		}
	}

	fmt.Fprintln(destination, "// Code generated by DecorGen, DO NOT EDIT.")
	return printer.Fprint(destination, token.NewFileSet(), decorNode)
}

func outputPackagePath(destination string) string {
	if destination != "" {
		dstPath, err := filepath.Abs(filepath.Dir(destination))
		if err == nil {
			pkgPath, err := parsePackageImport(dstPath)
			if err == nil {
				return pkgPath
			} else {
				log.Println("Unable to infer -self_package from destination file path:", err)
			}
		} else {
			log.Println("Unable to determine destination file path:", err)
		}
	}

	return ""
}

func parsePackageImport(srcDir string) (string, error) {
	moduleMode := os.Getenv("GO111MODULE")
	// trying to find the module
	if moduleMode != "off" {
		currentDir := srcDir
		for {
			dat, err := ioutil.ReadFile(filepath.Join(currentDir, "go.mod"))
			if os.IsNotExist(err) {
				if currentDir == filepath.Dir(currentDir) {
					// at the root
					break
				}
				currentDir = filepath.Dir(currentDir)
				continue
			} else if err != nil {
				return "", err
			}
			modulePath := modfile.ModulePath(dat)
			return filepath.ToSlash(filepath.Join(modulePath, strings.TrimPrefix(srcDir, currentDir))), nil
		}
	}
	// fall back to GOPATH mode
	goPaths := os.Getenv("GOPATH")
	if goPaths == "" {
		return "", fmt.Errorf("GOPATH is not set")
	}
	goPathList := strings.Split(goPaths, string(os.PathListSeparator))
	for _, goPath := range goPathList {
		sourceRoot := filepath.Join(goPath, "src") + string(os.PathSeparator)
		if strings.HasPrefix(srcDir, sourceRoot) {
			return filepath.ToSlash(strings.TrimPrefix(srcDir, sourceRoot)), nil
		}
	}
	return "", errors.New("error outside path")
}

func parameterizedType(typeName ast.Expr, currType *ast.TypeSpec) ast.Expr {
	if currType.TypeParams != nil {
		types := make([]ast.Expr, 0)
		for _, field := range currType.TypeParams.List {
			for _, name := range field.Names {
				types = append(
					types,
					&ast.Ident{Name: name.Name},
				)
			}
		}

		if len(types) == 1 {
			return &ast.IndexExpr{
				X:     typeName,
				Index: types[0],
			}
		}

		return &ast.IndexListExpr{
			X:       typeName,
			Indices: types,
		}
	}

	return typeName
}

func funcBodyWithTracing(method *ast.Field) *ast.BlockStmt {
	ftype, ok := method.Type.(*ast.FuncType)
	if !ok {
		return nil
	}

	hasContextArg := false
	argNames := make([]ast.Expr, 0)
	if ftype.Params != nil {
		for _, field := range ftype.Params.List {
			for _, name := range field.Names {
				argNames = append(argNames, name)
			}

			if isContext(field.Type) {
				hasContextArg = true
			}
		}
	}

	hasReturnError := false
	retNames := make([]ast.Expr, 0)
	if ftype.Results != nil {
		for f, field := range ftype.Results.List {
			if isA(field.Type, "error") {
				retNames = append(retNames, ast.NewIdent("err"))
				hasReturnError = true
			} else {
				retNames = append(retNames, ast.NewIdent(fmt.Sprintf("val%d", f)))
			}
		}
	}

	callOrigin := &ast.CallExpr{
		Fun: &ast.SelectorExpr{
			X: &ast.SelectorExpr{
				X: &ast.Ident{Name: "d"},
				Sel: &ast.Ident{
					Name: "origin",
				},
			},
			Sel: &ast.Ident{Name: method.Names[0].Name},
		},
		Args: argNames,
	}

	if !hasContextArg {
		return &ast.BlockStmt{
			List: []ast.Stmt{
				// callOrigin origin method
				&ast.ReturnStmt{
					Results: []ast.Expr{callOrigin},
				},
			},
		}
	}

	if ftype.Results == nil {
		return &ast.BlockStmt{
			List: []ast.Stmt{
				startTracerStatement(method), // spanCtx, span := t.tracerName.Start(ctx, "GetAdminBanners")
				endTracerStatement(method),   // defer span.End()

				&ast.ExprStmt{X: callOrigin},
			},
		}
	}

	if hasReturnError {
		return &ast.BlockStmt{
			List: []ast.Stmt{
				startTracerStatement(method), // spanCtx, span := t.tracerName.Start(ctx, "GetAdminBanners")
				endTracerStatement(method),   // defer span.End()

				// callOrigin origin method
				&ast.AssignStmt{
					Lhs: retNames,
					Tok: token.DEFINE,
					Rhs: []ast.Expr{callOrigin},
				},

				&ast.IfStmt{
					Cond: checkErrorNotNilExpr(), // if err != nil
					Body: &ast.BlockStmt{
						List: []ast.Stmt{
							addErrorStatement(method),       //	span.RecordError(err)
							setErrorStatusStatement(method), //	span.SetStatus(codes.Error, err.Error())
						},
					},
				},

				&ast.ReturnStmt{
					Results: retNames,
				},
			},
		}
	}

	return &ast.BlockStmt{
		List: []ast.Stmt{
			startTracerStatement(method), // spanCtx, span := t.tracerName.Start(ctx, "GetAdminBanners")
			endTracerStatement(method),   // defer span.End()

			// callOrigin origin method
			&ast.ReturnStmt{
				Results: []ast.Expr{callOrigin},
			},
		},
	}
}

func checkErrorNotNilExpr() ast.Expr {
	return &ast.BinaryExpr{
		X:  ast.NewIdent("err"),
		Op: token.NEQ,
		Y:  ast.NewIdent("nil"),
	}
}

// otel.Tracer(requestType(ctx)).Start(ctx, fc.Field.Name)
func startTracerStatement(method *ast.Field) ast.Stmt {
	if len(method.Names) == 0 {
		panic("method must have a name")
	}

	return &ast.AssignStmt{
		Lhs: []ast.Expr{
			&ast.Ident{Name: "ctx"},
			&ast.Ident{Name: "span"},
		},
		Tok: token.DEFINE,
		Rhs: []ast.Expr{
			&ast.CallExpr{
				Fun: &ast.SelectorExpr{
					X: &ast.CallExpr{
						Fun: &ast.SelectorExpr{
							X:   ast.NewIdent("otel"),
							Sel: ast.NewIdent("Tracer"),
						},
						Args: []ast.Expr{
							&ast.SelectorExpr{
								X:   ast.NewIdent("d"),
								Sel: ast.NewIdent("tracerName"),
							},
						},
					},
					Sel: &ast.Ident{Name: "Start"},
				},
				Args: []ast.Expr{
					ast.NewIdent("ctx"),
					stringLit(method.Names[0].Name),
				},
			},
		},
	}
}

func endTracerStatement(_ *ast.Field) ast.Stmt {
	return &ast.DeferStmt{
		Call: &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("span"),
				Sel: ast.NewIdent("End"),
			},
		},
	}
}

// span.RecordError(err)
func addErrorStatement(_ *ast.Field) ast.Stmt {
	return &ast.ExprStmt{
		X: &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("span"),
				Sel: ast.NewIdent("RecordError"),
			},
			Args: []ast.Expr{
				ast.NewIdent("err"),
			},
		},
	}
}

// span.SetStatus(codes.Error, err.Error())
func setErrorStatusStatement(_ *ast.Field) ast.Stmt {
	return &ast.ExprStmt{
		X: &ast.CallExpr{
			Fun: &ast.SelectorExpr{
				X:   ast.NewIdent("span"),
				Sel: ast.NewIdent("SetStatus"),
			},
			Args: []ast.Expr{
				&ast.SelectorExpr{
					X:   ast.NewIdent("codes"),
					Sel: ast.NewIdent("Error"),
				},
				&ast.CallExpr{
					Fun: &ast.SelectorExpr{
						X:   ast.NewIdent("err"),
						Sel: ast.NewIdent("Error"),
					},
				},
			},
		},
	}
}

func isA(Type ast.Expr, expectedTypeName string) bool {
	typeName, ok := Type.(*ast.Ident)
	if !ok {
		return false
	}

	return typeName.Name == expectedTypeName
}

func isContext(Type ast.Expr) bool {
	typeName, ok := Type.(*ast.SelectorExpr)
	if !ok {
		return false
	}

	return isA(typeName.X, "context") && isA(typeName.Sel, "Context")
}

func stringLit(s string) *ast.BasicLit {
	return &ast.BasicLit{
		ValuePos: 0,
		Kind:     token.STRING,
		Value:    fmt.Sprintf("\"%s\"", s),
	}
}
